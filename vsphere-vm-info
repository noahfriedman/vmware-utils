#!/usr/bin/env python
# vsphere-vm-info --- retrieve information about registered vm by name

# Author: Noah Friedman <friedman@splode.com>
# Created: 2017-11-02
# Public domain

# $Id: vsphere-vm-info,v 1.20 2018/07/23 16:57:50 friedman Exp $

# Commentary:
# Code:

from   __future__ import print_function
from   pyVmomi    import vim

import vspherelib     as vsl
import sys

#import httplib
#httplib.HTTPConnection.debuglevel = 1

proplist = [
    'config.annotation',
    'config.bootOptions.bootDelay',
    'config.cpuHotAddEnabled',
    'config.cpuHotRemoveEnabled',
    'config.files.vmPathName',
    'config.guestFullName',
    'config.hardware.device',
    'config.hardware.memoryMB',
    'config.hardware.numCPU',
    'config.hardware.numCoresPerSocket',
    'config.memoryHotAddEnabled',
    'config.template',
    'config.uuid',
    'config.version',

    'guest.hostName',
    'guest.net',

    'name',

    #'resourcePool.name',         # separate MO, can't fetch from vm proplist
    'resourcePool',

    'summary.config.numEthernetCards',
    'summary.config.numVirtualDisks',
    'summary.runtime.bootTime',
    #'summary.runtime.host.name', # separate MO, can't fetch from vm proplist
    'summary.runtime.host',

    'summary.runtime.powerState',
    'summary.runtime.question',
    'summary.storage', ]

proplist_verbose = [
    #'config.extraConfig.guestinfo.json', # can't retrieve if undefined
    'config.extraConfig',

    'config.instanceUuid',
    'config.locationId',
    'config.changeVersion',
    'config.tools.afterPowerOn',
    'config.tools.afterResume',
    'config.tools.beforeGuestReboot',
    'config.tools.beforeGuestShutdown',
    'config.tools.beforeGuestStandby',
    'config.tools.syncTimeWithHost',
    'config.tools.toolsUpgradePolicy',
    'config.flags.disableAcceleration',
    'config.flags.diskUuidEnabled',
    'config.flags.enableLogging',
    'config.flags.faultToleranceType',
    'config.flags.htSharing',
    'config.flags.monitorType',
    'config.flags.recordReplayEnabled',
    'config.flags.runWithDebugInfo',
    'config.flags.snapshotDisabled',
    'config.flags.snapshotLocked',
    'config.flags.snapshotPowerOffBehavior',
    'config.flags.useToe',
    'config.flags.virtualExecUsage',
    'config.flags.virtualMmuUsage',
    'config.defaultPowerOps.defaultPowerOffType',
    'config.defaultPowerOps.defaultResetType',
    'config.defaultPowerOps.defaultSuspendType',
    'config.defaultPowerOps.powerOffType',
    'config.defaultPowerOps.resetType',
    'config.defaultPowerOps.standbyAction',
    'config.defaultPowerOps.suspendType', ]

moId_types = [ vim.HostSystem, vim.ResourcePool ]
moId_map   = {}


def get_args():
    p = vsl.ArgumentParser()
    p.add( '-a', '--all',     action='store_true', help='Retrieve all known VMs' )
    p.add( '-v', '--verbose', action='store_true', help='Display extended info' )
    p.add( 'vm', nargs='*',                        help='VM names, if not all' )

    args = p.parse()
    if not args.all and not args.vm:
        vsl.printerr( 'Specify VM names or -a (--all)' )
        sys.exit (1)
    return args


def storage_size( storage ):
    comb = storage.committed + storage.uncommitted
    return vsl.scale_size( comb )

def plural( text, n ):
    if int( n ) != 1 and int( n ) != -1:
        text += 's'
    return text

def print_vm( vsi, vmflat, verbose, sep="" ):
    stdindent =  -17
    indentL    = stdindent - 3
    indentS    = " " * abs( indentL )
    farindentL = stdindent - 10
    farindentS = " " * abs( farindentL )

    def p( *parm ):
        if parm[1] is None: return
        w = stdindent
        if type( parm[0] ) is int:
            w = parm[0]
            parm = parm[1:]
        nl = 1
        if type(parm[-1]) is str and parm[-1] == "":
            nl   = 0
            parm = parm[0:-1]
        s = '%*s : %s' % (w, parm[0], str.join( " ", map( str, parm[1:] ) ))
        if nl: print( s )
        else:  print( s, end="" )

    def pi( *parm ):
        print( indentS, end="" )
        p( *parm )

    def pf( label, extra, dic, attrs ):
        idx = 0
        if extra:
            p( label, extra )
        else:
            try:
                # Look up key before writing, in case of exception.
                val = dic[ attrs[ 0 ]]
                p( label, '' )
                p( farindentL, attrs[ 0 ], val )
                idx = 1
            except KeyError:
                pass
        for attr in attrs[ idx: ]:
            try:
                pi( farindentL, attr, dic[ attr ] )
            except KeyError:
                pass
            except:
                pi( farindentL, attr, dic.__dict__[ attr ] )

    def pf2( label, dic, attrs ):
        p( label, '' )
        p( farindentL, attrs[0][0], dic[ attrs[0][1] ] )
        for a, b in attrs[1:]:
            try:    pi( farindentL, a, dic[ b ] )
            except: pass

    vm = vsl.dotted_to_nested_dict( vmflat )

    vm_conf = vm[ 'config' ]
    gu_conf = vm[ 'guest' ]
    su_conf = vm[ 'summary' ]

    hw_conf = vm_conf[ 'hardware' ]
    ex_conf = vm_conf.get( 'extraConfig' )

    numCPU = hw_conf[ 'numCPU' ]
    coreargs = [plural( 'core', numCPU )]
    if hw_conf.get( 'numCoresPerSocket' ):
        nsockets = numCPU / hw_conf[ 'numCoresPerSocket' ]
        coreargs.append( plural('%d socket' % nsockets, nsockets ))
    if vm_conf.get( 'cpuHotAddEnabled' ):
        coreargs.append( 'hot add enabled' )
    if vm_conf.get( 'cpuHotRemoveEnabled' ):
        coreargs.append( 'hot remove enabled' )

    memargs = [vsl.scale_size( hw_conf[ 'memoryMB' ] * 1024 * 1024)]
    if vm_conf.get( 'memoryHotAddEnabled' ):
        memargs.append( 'hot add enabled' )

    vm_name = vm[ 'name' ]
    if vm_conf[ 'template' ]:
        p( 'VM Name', vm_name, '    [TEMPLATE]' )
    else:
        p( 'VM Name', vm_name )
        hn = gu_conf.get( 'hostName' )
        if hn and hn != vm_name:
            p( 'VM Guest Name', hn )

    p( 'VM Id',   'vim.VirtualMachine:' + vm[ 'obj' ]._moId )
    p( 'VM UUID', vm_conf[ 'uuid' ] )
    if verbose:
        p( 'Instance Id',    vm_conf.get( 'instanceUuid' ))
        p( 'Location Id',    vm_conf.get( 'locationId' ))
        p( 'Config modtime', vm_conf[ 'changeVersion' ] )
    p( 'VMX', vm_conf[ 'files' ][ 'vmPathName' ] )

    folder = vsi.get_vm_folder_path( vm[ 'obj' ] )
    p( 'Folder',      folder )

    resourcePool = vm.get( 'resourcePool' )
    try:
        p( 'Resource Pool', moId_map[ resourcePool._moId ] )
    except KeyError:
        p( 'Resource Pool', resourcePool._moId )
    except AttributeError:
        pass

    p( 'Guest type',  vm_conf.get( 'guestFullName' ))
    p( 'HW version',  str.replace( vm_conf[ 'version' ], 'vmx-', '' ))
    p( 'CPU',         numCPU, str.join( ", ", coreargs ) )
    p( 'Memory',      str.join( ", ", memargs ))

    p( 'NICs',        su_conf[ 'config' ][ 'numEthernetCards' ] )
    p( 'Disks',       su_conf[ 'config' ][ 'numVirtualDisks' ] )
    p( 'Storage',     storage_size( su_conf[ 'storage' ] ))

    rt_conf = su_conf[ 'runtime' ]
    host    = rt_conf[ 'host' ]
    try:
        p( 'Hypervisor',  moId_map[ host._moId ] )
    except KeyError:
        p( 'Hypervisor',  host._moId )

    p( 'Boot delay',  vm_conf[ 'bootOptions' ][ 'bootDelay' ], "ms" )
    p( 'State',       rt_conf[ 'powerState' ] )

    if rt_conf[ 'powerState' ] == "poweredOn":
        p( 'Boot time', rt_conf.get( 'bootTime' ))

    if verbose:
        pf2( 'Tools ', vm_conf[ 'tools' ],
             ( ('Power On' , 'afterPowerOn'),
               ('Resume'   , 'afterResume'),
               ('Standby'  , 'beforeGuestStandby'),
               ('Shutdown' , 'beforeGuestShutdown'),
               ('Reboot'   , 'beforeGuestReboot'),
               ('Upgrade'  , 'toolsUpgradePolicy'),
               ('syncTime' , 'syncTimeWithHost'), ))

    if verbose:
        pf( 'Flags', '', vm_conf[ 'flags' ],
            sorted( ( 'disableAcceleration',
                      'enableLogging',
                      'useToe',
                      'runWithDebugInfo',
                      'monitorType',
                      'htSharing',
                      'snapshotDisabled',
                      'snapshotLocked',
                      'diskUuidEnabled',
                      'virtualMmuUsage',
                      'virtualExecUsage',
                      'snapshotPowerOffBehavior',
                      'recordReplayEnabled',
                      'faultToleranceType',
                      'cbrcCacheEnabled', )))

    if verbose:
        pf( 'Power Ops', '', vm_conf[ 'defaultPowerOps' ],
            sorted( ( 'powerOffType',
                      'suspendType',
                      'resetType',
                      'defaultPowerOffType',
                      'defaultSuspendType',
                      'defaultResetType',
                      'standbyAction', )))

    if True:
        nics = vsl.get_seq_type( hw_conf[ 'device' ], vim.vm.device.VirtualEthernetCard )
        for nic in nics:
            devtype = nic._wsdlName.replace( 'Virtual', '' ).lower()
            netlabel = vsi.get_network_label( nic )
            pf( nic.deviceInfo.label, '{} on "{}"'.format( devtype, netlabel ), nic,
                ( 'macAddress', ) )

            if verbose:
                pi( farindentL, 'wakeOnLanEnabled',  nic.wakeOnLanEnabled )
                pi( farindentL, 'startConnected',    nic.connectable.startConnected )
                pi( farindentL, 'connected',         nic.connectable.connected )
                pi( farindentL, 'allowGuestControl', nic.connectable.allowGuestControl )

            if rt_conf[ 'powerState' ] == "poweredOn":
                gnic = filter( lambda g: g.macAddress == nic.macAddress, gu_conf[ 'net' ] )
                if len( gnic ):
                    cidr = vsi.vmnic_cidrs( gnic[0] )
                    if cidr and len(cidr) > 0:
                        spc  = " " * (abs( farindentL ) + abs( indentL ) + 2)
                        pi( farindentL, 'IP Addresses', cidr[0] )
                        for ip in cidr[1:]:
                            print( spc, ip )

    # This is a custom key I insert into our VMs
    if verbose:
        try:
            p( 'Guest json', ex_conf.guestinfo.json )
        except:
            pass

    if verbose:
        try:
            annot = vm_conf['annotation']
            annot = vsl.fold_text( annot, maxlen=70, indent=abs( indentL ) )
            if annot.find ("\n") >= 0:
                annot = "\n" + indentS + annot
            if annot != "":
                p( 'Annotation', annot )
        except:
            pass

    try:
        p( 'Question', rt_conf[ 'question' ].text )
    except KeyError:
        pass

    print( sep )

def init_moId_map( vsi ):
    timer = vsl.Timer('init moId map')
    global moId_map
    moId_map = dict( map( lambda o: ( str( o[ 'obj' ]._moId ), o[ 'name' ] ),
                          vsi.get_obj_props( moId_types, [ 'name' ] )))
    timer.report()

def main():
    args = get_args()
    vsi  = vsl.vmomiConnect( args )

    init_moId_map( vsi )

    if args.verbose:
        proplist.extend( proplist_verbose )

    sep = '-' * 78
    if args.vm:
        # Get matching VMs by name.
        vmlist = vsi.find_vm( args.vm )
        if not vmlist:
            return

        # Get the properties we want from the resulting maetches
        vmlist = vsi.get_obj_props( [vim.VirtualMachine], proplist, vmlist )
        n = len( vmlist )
        for vm in vmlist:
            n -= 1
            if not n:
                sep = ""
            print_vm( vsi, vm, args.verbose, sep=sep )
    else:
        vmlist = vsi.get_obj_props( [vim.VirtualMachine], proplist )

        timer = vsl.Timer('sort')
        vmlist.sort( cmp=lambda a, b: cmp( a[ 'name' ], b[ 'name' ] ))
        timer.report()

        timer = vsl.Timer('print')
        n = len( vmlist )
        for vm in vmlist:
            n -= 1
            if not n:
                sep = ""
            print_vm( vsi, vm, args.verbose, sep=sep )
        timer.report()


##########

if __name__ == '__main__':
    main()

# eof
