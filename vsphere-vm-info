#!/usr/bin/env python
# vsphere-vm-info --- retrieve information about registered vm by name

# Author: Noah Friedman <friedman@splode.com>
# Created: 2017-11-02
# Public domain

# $Id: vsphere-vm-info,v 1.37 2018/12/05 20:25:22 friedman Exp $

# Commentary:
# Code:

from   __future__ import print_function
from   pyVmomi    import vim

import vspherelib     as vsl
import sys

#import httplib
#httplib.HTTPConnection.debuglevel = 1

hw_compat = {
    '14' : [ 'ESXi 6.7', 'Workstation Pro 14.x', 'Fusion 10.x', 'Player 14.x' ],
    '13' : [ 'ESXi 6.5' ],
    '11' : [ 'ESXi 6.0', 'Workstation 11.x', 'Fusion 7.x', 'Player 7.x' ],
    '10' : [ 'ESXi 5.5', 'Workstation 10.x', 'Fusion 6.x', 'Player 6.x' ],
     '9' : [ 'ESXi 5.1', 'Workstation 9.x',  'Fusion 5.x', 'Player 5.x' ],
     '8' : [ 'ESXi 5.0', 'Workstation 8.x',  'Fusion 4.x', 'Player 4.x' ],
     '7' : [ 'ESXi/ESX 4.x', 'Server 2.x', 'Workstation 6.5.x/7.x', 'Fusion 2.x/3.x', 'Player 3.x' ],
     '4' : [ 'ESX 3.x', 'Server 1.x', 'Lab Manager 2.x', 'ACE 2.x' ],
}

proplist = [
    'config.annotation',
    'config.bootOptions.bootDelay',
    'config.cpuHotAddEnabled',
    'config.cpuHotRemoveEnabled',
    'config.files.vmPathName',
    'config.guestFullName',
    'config.hardware.device',
    'config.hardware.memoryMB',
    'config.hardware.numCPU',
    'config.hardware.numCoresPerSocket',
    'config.memoryHotAddEnabled',
    'config.nestedHVEnabled',
    'config.template',
    'config.uuid',
    'config.version',

    'guest.hostName',
    'guest.net',

    'layoutEx.disk',
    'layoutEx.file',

    'name',
    'parent',

    #'resourcePool.name',         # separate MO, can't fetch from vm proplist
    'resourcePool',

    'summary.config.numEthernetCards',
    'summary.config.numVirtualDisks',
    'summary.runtime.bootTime',
    #'summary.runtime.host.name', # separate MO, can't fetch from vm proplist
    'summary.runtime.host',

    'summary.runtime.powerState',
    'summary.runtime.question',
    'summary.storage', ]

proplist_verbose = [
    #'config.extraConfig.guestinfo.json', # can't retrieve if undefined
    'config.extraConfig',

    'config.instanceUuid',
    'config.locationId',
    'config.changeVersion',
    'config.tools.afterPowerOn',
    'config.tools.afterResume',
    'config.tools.beforeGuestReboot',
    'config.tools.beforeGuestShutdown',
    'config.tools.beforeGuestStandby',
    'config.tools.syncTimeWithHost',
    'config.tools.toolsUpgradePolicy',
    'config.flags.disableAcceleration',
    'config.flags.diskUuidEnabled',
    'config.flags.enableLogging',
    'config.flags.faultToleranceType',
    'config.flags.htSharing',
    'config.flags.monitorType',
    'config.flags.runWithDebugInfo',
    'config.flags.snapshotDisabled',
    'config.flags.snapshotLocked',
    'config.flags.snapshotPowerOffBehavior',
    'config.flags.virtualExecUsage',
    'config.flags.virtualMmuUsage',
    'config.guestId',
    'config.defaultPowerOps.defaultPowerOffType',
    'config.defaultPowerOps.defaultResetType',
    'config.defaultPowerOps.defaultSuspendType',
    'config.defaultPowerOps.powerOffType',
    'config.defaultPowerOps.resetType',
    'config.defaultPowerOps.standbyAction',
    'config.defaultPowerOps.suspendType',

    'guest.toolsStatus',
    'guest.toolsRunningStatus',
    'guest.toolsVersionStatus',
    'guest.toolsVersionStatus2',
    'guest.toolsVersion',
    'guest.guestState',
    'guest.screen.width',
    'guest.screen.height',
]

moId_types = [ vim.HostSystem, vim.ResourcePool ]
moId_map   = {}
folder_map = None


def get_args():
    p = vsl.ArgumentParser( loadrc=True )
    p.add( '-a', '--all',     action='store_true', help='Retrieve all known VMs' )
    p.add( '-v', '--verbose', action='store_true', help='Display extended info' )
    p.add( 'vm', nargs='*',                        help='VM names, if not all' )

    args = p.parse()
    if not args.all and not args.vm:
        vsl.printerr( 'Specify VM names or -a (--all)' )
        sys.exit( 1 )
    return args


def storage_size( storage ):
    comb = storage.committed + storage.uncommitted
    return vsl.scale_size( comb )

def plural( text, n ):
    if abs( int( n ) ) != 1:
        text += 's'
    return text


stdindent  =  -17
indentL    = stdindent - 3
indentS    = " " * abs( indentL )
farindentL = stdindent - 10
farindentS = " " * abs( farindentL )

def p( *parm ):
    if parm[ 1 ] is None:
        return
    w = stdindent
    if isinstance( parm[ 0 ], (int, long) ):
        w = parm[ 0 ]
        parm = parm[ 1: ]
    end = '\n'
    if isinstance( parm[ -1 ], (str, unicode) ) and parm[ -1 ] == "":
        end  = ''
        parm = parm[ : -1 ]
    s = '%*s : %s' % (w, parm[ 0 ], str.join( " ", map( str, parm[ 1: ] ) ))
    print( s, end=end )

def pi( *parm ):
    print( indentS, end="" )
    p( *parm )

def pf( label, extra, dic, attrs ):
    idx = 0
    if extra:
        p( label, extra )
    else:
        try:
            # Look up key before writing, in case of exception.
            val = dic[ attrs[ 0 ]]
            p( label, '' )
            p( farindentL, attrs[ 0 ], val )
            idx = 1
        except KeyError:
            pass
    for attr in attrs[ idx : ]:
        try:
            pi( farindentL, attr, dic[ attr ] )
        except KeyError:
            pass
        except:
            pi( farindentL, attr, getattr( dic, attr ))

def pf2( label, dic, attrs ):
    p( label, '' )
    p( farindentL, attrs[0][0], dic[ attrs[0][1] ] )
    for a, b in attrs[ 1: ]:
        try:
            pi( farindentL, a, dic[ b ] )
        except:
            pass


class DisplayVM( object ):
    def __init__( self, vsi, vmprops, verbose=False, sep="" ):
        self.vsi = vsi
        self.vm = vsl.flat_to_nested_dict( vmprops, objtype=vsl.pseudoPropAttr )
        try:
            self.vm.config.extraConfig = vsl.flat_to_nested_dict(
                vsl.attr_to_dict( self.vm.config.extraConfig ),
                objtype=vsl.pseudoPropAttr )
        except AttributeError:
            pass
        self.verbose = verbose
        self.sep = sep
        self.display()

    def display( self ):
        vm      = self.vm

        self.display_name()
        self.display_location()
        self.display_resource_pool()
        if self.verbose:
            p( 'Guest family', vm.config.guestId )
        p( 'Guest type', vm.config.guestFullName )
        self.display_hw_ver()
        self.display_cpu()
        self.display_mem()
        p( 'NICs',    vm.summary.config.numEthernetCards )
        p( 'Disks',   vm.summary.config.numVirtualDisks )
        p( 'Storage', storage_size( vm.summary.storage ))
        p( 'Nested HV', vm.config.nestedHVEnabled )
        self.display_host()
        self.display_power_state()

        if self.verbose:
            self.display_tools()
            self.display_guest()
            self.display_flags()
            self.display_power_ops()
            self.display_vnc()

        self.display_networks()
        self.display_disks()

        # This is a custom key I insert into my VMs
        if self.verbose:
            try:
                p( 'Guest json', vm.config.extraConfig.guestinfo.json )
            except AttributeError:
                pass

            self.display_annotation()

        self.display_question()
        print( self.sep )

    def display_name( self ):
        if self.vm.config.template:
            p( 'VM Name', self.vm.name, '    [TEMPLATE]' )
        else:
            p( 'VM Name', self.vm.name )
            try:
                hn = self.vm.guest.hostName
                if hn and hn != self.vm.name:
                    p( 'VM Guest Name', hn )
            except AttributeError:
                pass

    def display_location( self ):
        vm      = self.vm
        vm_conf = self.vm.config

        p( 'VM moId', vm.obj._moId )
        p( 'VM UUID', vm_conf.uuid)
        if self.verbose:
            p( 'Instance Id',    vm_conf.instanceUuid )
            p( 'Location Id',    getattr( vm_conf, 'locationId', None ))
            p( 'Config modtime', vm_conf.changeVersion )
        p( 'VMX', vm_conf.files.vmPathName )

        try:
            folder = folder_map[ vm.parent ]
            p( 'Folder', folder )
        except (AttributeError, KeyError):
            pass

    def display_resource_pool( self ):
        try:
            resourcePool = self.vm.resourcePool
            p( 'Resource Pool', moId_map[ resourcePool._moId ] )
        except KeyError:
            p( 'Resource Pool', resourcePool._moId )
        except AttributeError:
            pass

    def display_hw_ver( self ):
        hw_ver = self.vm.config.version[ 4: ]  # skip 'vmx-'
        if hw_ver[ 0 ] == '0':
            hw_ver = hw_ver[ 1: ]
        try:
            hw_desc = '\t({})'.format( hw_compat[ hw_ver ][0] )
        except KeyError:
            hw_desc = ""
        hw_ver += hw_desc
        p( 'HW version',  hw_ver )

    def display_cpu( self ):
        vm_conf = self.vm.config
        hw_conf = self.vm.config.hardware
        numCPU  = hw_conf.numCPU

        coreargs = [plural( 'core', numCPU )]
        if getattr( hw_conf, 'numCoresPerSocket', None ):
            nsockets = numCPU / hw_conf.numCoresPerSocket
            coreargs.append( plural('%d socket' % nsockets, nsockets ))
        if getattr( vm_conf, 'cpuHotAddEnabled', False ):
            coreargs.append( 'hot add enabled' )
        if getattr( vm_conf, 'cpuHotRemoveEnabled', False ):
            coreargs.append( 'hot remove enabled' )

        p( 'CPU', numCPU, str.join( ', ', coreargs ) )

    def display_mem( self ):
        memoryMB = self.vm.config.hardware.memoryMB
        memargs = [ vsl.scale_size( memoryMB * 2**20 ) ]
        if getattr( self.vm.config, 'memoryHotAddEnabled', False ):
            memargs.append( 'hot add enabled' )
        p( 'Memory', str.join( ', ', memargs ))

    def display_host( self ):
        host = self.vm.summary.runtime.host
        try:
            p( 'Hypervisor', moId_map[ host._moId ] )
        except KeyError:
            p( 'Hypervisor', host._moId )

    def display_power_state( self ):
        rt_conf = self.vm.summary.runtime
        p( 'Boot delay',  self.vm.config.bootOptions.bootDelay, "ms" )
        p( 'State',       rt_conf.powerState )
        try:
            p( 'Boot time', rt_conf.bootTime )
        except AttributeError:
            pass

    def display_tools( self ):
        pf2( 'Tools ', self.vm.config.tools,
             ( ('Power On' , 'afterPowerOn'),
               ('Resume'   , 'afterResume'),
               ('Standby'  , 'beforeGuestStandby'),
               ('Shutdown' , 'beforeGuestShutdown'),
               ('Reboot'   , 'beforeGuestReboot'),
               ('Upgrade'  , 'toolsUpgradePolicy'),
               ('syncTime' , 'syncTimeWithHost'), ))

    def display_guest( self ):
        pf2( 'Guest Tools', self.vm.guest,
             ( ('Tools Status',    'toolsStatus'),
               ('Running Status',  'toolsRunningStatus'),
               ('Version Status',  'toolsVersionStatus'),
               ('Version Status2', 'toolsVersionStatus2'),
               ('Version',         'toolsVersion'),
               ('State',           'guestState'),
             ))
        try:
            pf2( 'Screen', self.vm.guest.screen,
                 ( ('Width',    'width'),
                   ('Height',  'height'),
                 ))
        except AttributeError:
            pass

    def display_flags( self ):
        pf( 'Flags', '', self.vm.config.flags,
            sorted( ( 'disableAcceleration',
                      'enableLogging',
                      'runWithDebugInfo',
                      'monitorType',
                      'htSharing',
                      'snapshotDisabled',
                      'snapshotLocked',
                      'diskUuidEnabled',
                      'virtualMmuUsage',
                      'virtualExecUsage',
                      'snapshotPowerOffBehavior',
                      'faultToleranceType', )))

    def display_power_ops( self ):
        pf( 'Power Ops', '', self.vm.config.defaultPowerOps,
            sorted( ( 'powerOffType',
                      'suspendType',
                      'resetType',
                      'defaultPowerOffType',
                      'defaultSuspendType',
                      'defaultResetType',
                      'standbyAction', )))

    def display_vnc( self ):
        try:
            vnc = self.vm.config.extraConfig.RemoteDisplay.vnc
            if getattr( vnc, 'key', False ):
                vnc.key = '(set)'
            else:
                vnc.key = 'None'
            pf( 'VNC', '', vnc,
                ( 'enabled',
                  'port', 'frob',
                  'key', ))
        except AttributeError:
            return

    def display_networks( self ):
        for nic in self.vsi.vmguest_nic_info( self.vm ):
            pf( nic[ 'label' ], '{} on "{}"'.format( nic[ 'type' ], nic[ 'netlabel' ] ),
                nic, ( 'macAddress', ) )

            if self.verbose:
                obj = nic[ 'obj' ]
                pi( farindentL, 'wakeOnLanEnabled',  obj.wakeOnLanEnabled )
                pi( farindentL, 'startConnected',    obj.connectable.startConnected )
                pi( farindentL, 'connected',         obj.connectable.connected )
                pi( farindentL, 'allowGuestControl', obj.connectable.allowGuestControl )

            cidr = nic.get( 'ip' )
            if cidr:
                spc  = " " * (abs( farindentL ) + abs( indentL ) + 2)
                pi( farindentL, 'IP Addresses', cidr[0] )
                for ip in cidr[1:]:
                    print( spc, ip )

    def display_disks( self ):
        for disk in self.vsi.vmguest_disk_info( self.vm ):
            disk[ 'capacity' ]  = vsl.scale_size( disk[ 'capacity' ] );
            disk[ 'allocated' ] = vsl.scale_size( disk[ 'allocated' ] );

            vfrcache = 'vflash read cache'
            try:
                desc = '{}, blk={}'.format(
                    vsl.scale_size( disk[ 'vflash_reserve' ] ),
                    vsl.scale_size( disk[ 'vflash_blksz'   ] ) )
                disk[ vfrcache ] = desc
            except KeyError:
                pass

            pf( disk[ 'label' ], disk[ 'fileName' ],
                disk, ( 'capacity',
                        'allocated',
                        'device',
                        'backing',
                        'deviceName',
                        'diskMode',
                        vfrcache, ) )


    def _display_text( self, label, text, *options ):
        text = vsl.fold_text( text, maxlen=70, indent=abs( indentL ) )
        if text.find ("\n") >= 0:
            text = "\n" + indentS + text
        if text != "":
            p( label, text )
        if options:
            print()
            for choice in options:
                print( indentS, choice )

    def display_annotation( self ):
        try:
            self._display_text( 'Annotation', self.vm.config.annotation )
        except:
            pass

    def display_question( self ):
        try:
            question = self.vm.summary.runtime.question
            choices = [ '\t[{}] {}'.format( choice.key, choice.summary )
                        for choice in question.choice.choiceInfo ]
            try:
                choices[ question.choice.defaultIndex ] += ' (default)'
            except (KeyError, AttributeError):
                pass
            self._display_text( 'Question', question.text, *choices )
        except AttributeError:
            pass


def init_folder_map( vsi ):
    timer = vsl.Timer('init folder map')
    p2f = vsi.path_to_subfolder_map( 'vm' )
    global folder_map
    folder_map = vsl.inverted_dict ( p2f )
    timer.report()

def init_moId_map( vsi ):
    timer = vsl.Timer('init moId map')
    global moId_map
    moId_map = dict( map( lambda o: ( str( o[ 'obj' ]._moId ), o[ 'name' ] ),
                          vsi.get_obj_props( moId_types, [ 'name' ] )))
    timer.report()


def display_vmlist( vsi, vmlist, verbose ):
    sep = '-' * 78
    timer = vsl.Timer('print')
    n = len( vmlist )
    for vm in vmlist:
        n -= 1
        if not n:
            sep = ""
        DisplayVM( vsi, vm, verbose, sep=sep )
    timer.report()

def main():
    args = get_args()
    vsi  = vsl.vmomiConnect( args )

    init_folder_map( vsi )
    init_moId_map( vsi )

    if args.verbose:
        proplist.extend( proplist_verbose )

    if args.vm:
        vmlist = vsi.find_vm( args.vm )
        if not vmlist:
            return
        if args.verbose:
            for vm in vmlist:
                vm.RefreshStorageInfo()
        vmlist = vsi.get_obj_props( [vim.VirtualMachine], proplist, vmlist )
    else:
        vmlist = vsi.get_obj_props( [vim.VirtualMachine], proplist )
        vmlist.sort( cmp=lambda a, b: cmp( a[ 'name' ], b[ 'name' ] ))

    display_vmlist( vsi, vmlist, args.verbose )


##########

if __name__ == '__main__':
    main()

# eof
