#!/usr/bin/env python
# vsphere-vm-info --- retrieve information about registered vm by name

# Author: Noah Friedman <friedman@splode.com>
# Created: 2017-11-02
# Public domain

# $Id: vsphere-vm-info,v 1.25 2018/08/08 12:25:24 friedman Exp $

# Commentary:
# Code:

from   __future__ import print_function
from   pyVmomi    import vim

import vspherelib     as vsl
import sys

#import httplib
#httplib.HTTPConnection.debuglevel = 1

hw_compat = {
    '14' : [ 'ESXi 6.7', 'Workstation Pro 14.x', 'Fusion 10.x', 'Player 14.x' ],
    '13' : [ 'ESXi 6.5' ],
    '11' : [ 'ESXi 6.0', 'Workstation 11.x', 'Fusion 7.x', 'Player 7.x' ],
    '10' : [ 'ESXi 5.5', 'Workstation 10.x', 'Fusion 6.x', 'Player 6.x' ],
     '9' : [ 'ESXi 5.1', 'Workstation 9.x',  'Fusion 5.x', 'Player 5.x' ],
     '8' : [ 'ESXi 5.0', 'Workstation 8.x',  'Fusion 4.x', 'Player 4.x' ],
     '7' : [ 'ESXi/ESX 4.x', 'Server 2.x', 'Workstation 6.5.x/7.x', 'Fusion 2.x/3.x', 'Player 3.x' ],
     '4' : [ 'ESX 3.x', 'Server 1.x', 'Lab Manager 2.x', 'ACE 2.x' ],
}

proplist = [
    'config.annotation',
    'config.bootOptions.bootDelay',
    'config.cpuHotAddEnabled',
    'config.cpuHotRemoveEnabled',
    'config.files.vmPathName',
    'config.guestFullName',
    'config.hardware.device',
    'config.hardware.memoryMB',
    'config.hardware.numCPU',
    'config.hardware.numCoresPerSocket',
    'config.memoryHotAddEnabled',
    'config.template',
    'config.uuid',
    'config.version',

    'guest.hostName',
    'guest.net',

    'name',

    #'resourcePool.name',         # separate MO, can't fetch from vm proplist
    'resourcePool',

    'summary.config.numEthernetCards',
    'summary.config.numVirtualDisks',
    'summary.runtime.bootTime',
    #'summary.runtime.host.name', # separate MO, can't fetch from vm proplist
    'summary.runtime.host',

    'summary.runtime.powerState',
    'summary.runtime.question',
    'summary.storage', ]

proplist_verbose = [
    #'config.extraConfig.guestinfo.json', # can't retrieve if undefined
    'config.extraConfig',

    'config.instanceUuid',
    'config.locationId',
    'config.changeVersion',
    'config.tools.afterPowerOn',
    'config.tools.afterResume',
    'config.tools.beforeGuestReboot',
    'config.tools.beforeGuestShutdown',
    'config.tools.beforeGuestStandby',
    'config.tools.syncTimeWithHost',
    'config.tools.toolsUpgradePolicy',
    'config.flags.disableAcceleration',
    'config.flags.diskUuidEnabled',
    'config.flags.enableLogging',
    'config.flags.faultToleranceType',
    'config.flags.htSharing',
    'config.flags.monitorType',
    'config.flags.recordReplayEnabled',
    'config.flags.runWithDebugInfo',
    'config.flags.snapshotDisabled',
    'config.flags.snapshotLocked',
    'config.flags.snapshotPowerOffBehavior',
    'config.flags.useToe',
    'config.flags.virtualExecUsage',
    'config.flags.virtualMmuUsage',
    'config.defaultPowerOps.defaultPowerOffType',
    'config.defaultPowerOps.defaultResetType',
    'config.defaultPowerOps.defaultSuspendType',
    'config.defaultPowerOps.powerOffType',
    'config.defaultPowerOps.resetType',
    'config.defaultPowerOps.standbyAction',
    'config.defaultPowerOps.suspendType', ]

moId_types = [ vim.HostSystem, vim.ResourcePool ]
moId_map   = {}


def get_args():
    p = vsl.ArgumentParser()
    p.add( '-a', '--all',     action='store_true', help='Retrieve all known VMs' )
    p.add( '-v', '--verbose', action='store_true', help='Display extended info' )
    p.add( 'vm', nargs='*',                        help='VM names, if not all' )

    args = p.parse()
    if not args.all and not args.vm:
        vsl.printerr( 'Specify VM names or -a (--all)' )
        sys.exit (1)
    return args


def storage_size( storage ):
    comb = storage.committed + storage.uncommitted
    return vsl.scale_size( comb )

def plural( text, n ):
    if abs( int( n ) ) != 1:
        text += 's'
    return text

def print_vm( vsi, vmflat, verbose, sep="" ):
    stdindent =  -17
    indentL    = stdindent - 3
    indentS    = " " * abs( indentL )
    farindentL = stdindent - 10
    farindentS = " " * abs( farindentL )

    def p( *parm ):
        if parm[1] is None: return
        w = stdindent
        if type( parm[0] ) is int:
            w = parm[0]
            parm = parm[1:]
        nl = 1
        if type(parm[-1]) is str and parm[-1] == "":
            nl   = 0
            parm = parm[0:-1]
        s = '%*s : %s' % (w, parm[0], str.join( " ", map( str, parm[1:] ) ))
        if nl: print( s )
        else:  print( s, end="" )

    def pi( *parm ):
        print( indentS, end="" )
        p( *parm )

    def pf( label, extra, dic, attrs ):
        idx = 0
        if extra:
            p( label, extra )
        else:
            try:
                # Look up key before writing, in case of exception.
                val = dic[ attrs[ 0 ]]
                p( label, '' )
                p( farindentL, attrs[ 0 ], val )
                idx = 1
            except KeyError:
                pass
        for attr in attrs[ idx: ]:
            try:
                pi( farindentL, attr, dic[ attr ] )
            except KeyError:
                pass
            except:
                pi( farindentL, attr, dic.__dict__[ attr ] )

    def pf2( label, dic, attrs ):
        p( label, '' )
        p( farindentL, attrs[0][0], dic[ attrs[0][1] ] )
        for a, b in attrs[1:]:
            try:    pi( farindentL, a, dic[ b ] )
            except: pass

    vm = vsl.flat_to_nested_dict( vmflat, objtype=vsl.pseudoPropAttr )

    vm_conf = vm.config
    hw_conf = vm.config.hardware
    gu_conf = vm.guest
    su_conf = vm.summary
    rt_conf = vm.summary.runtime
    ex_conf = getattr( vm.config, 'extraConfig', None )

    numCPU = hw_conf.numCPU
    coreargs = [plural( 'core', numCPU )]
    if getattr( hw_conf, 'numCoresPerSocket', None ):
        nsockets = numCPU / hw_conf.numCoresPerSocket
        coreargs.append( plural('%d socket' % nsockets, nsockets ))
    if getattr( vm_conf, 'cpuHotAddEnabled', False ):
        coreargs.append( 'hot add enabled' )
    if getattr( vm_conf, 'cpuHotRemoveEnabled', False ):
        coreargs.append( 'hot remove enabled' )

    memargs = [vsl.scale_size( hw_conf.memoryMB * 1024 * 1024)]
    if getattr( vm_conf, 'memoryHotAddEnabled', False ):
        memargs.append( 'hot add enabled' )

    if vm_conf.template:
        p( 'VM Name', vm.name, '    [TEMPLATE]' )
    else:
        p( 'VM Name', vm.name )
        hn = getattr( gu_conf, 'hostName', None )
        if hn and hn != vm.name:
            p( 'VM Guest Name', hn )

    p( 'VM moId', vm.obj._moId )
    p( 'VM UUID', vm_conf.uuid)
    if verbose:
        p( 'Instance Id',    vm_conf.instanceUuid )
        p( 'Location Id',    getattr( vm_conf, 'locationId', None ))
        p( 'Config modtime', vm_conf.changeVersion )
    p( 'VMX', vm_conf.files.vmPathName )

    try:
        folder = vsi.get_vm_folder_path( vm.obj )
        p( 'Folder', folder )
    except KeyError:
        pass

    resourcePool = getattr( vm, 'resourcePool', None )
    try:
        p( 'Resource Pool', moId_map[ resourcePool._moId ] )
    except KeyError:
        p( 'Resource Pool', resourcePool._moId )
    except AttributeError:
        pass

    p( 'Guest type',  vm_conf.guestFullName )

    hw_ver = vm_conf.version[4:]  # skip 'vmx-'
    if hw_ver[0] == '0': hw_ver = hw_ver[1:]
    try:
        hw_desc = '\t({})'.format( hw_compat[ hw_ver ][0] )
    except KeyError:
        hw_desc = ""
    hw_ver += hw_desc
    p( 'HW version',  hw_ver )

    p( 'CPU',         numCPU, str.join( ', ', coreargs ) )
    p( 'Memory',      str.join( ', ', memargs ))

    p( 'NICs',        su_conf.config.numEthernetCards )
    p( 'Disks',       su_conf.config.numVirtualDisks )
    p( 'Storage',     storage_size( su_conf.storage ))

    host = rt_conf.host
    try:
        p( 'Hypervisor',  moId_map[ host._moId ] )
    except KeyError:
        p( 'Hypervisor',  host._moId )

    p( 'Boot delay',  vm_conf.bootOptions.bootDelay, "ms" )
    p( 'State',       rt_conf.powerState )

    try:
        p( 'Boot time', rt_conf.bootTime )
    except AttributeError:
        pass

    if verbose:
        pf2( 'Tools ', vm_conf.tools,
             ( ('Power On' , 'afterPowerOn'),
               ('Resume'   , 'afterResume'),
               ('Standby'  , 'beforeGuestStandby'),
               ('Shutdown' , 'beforeGuestShutdown'),
               ('Reboot'   , 'beforeGuestReboot'),
               ('Upgrade'  , 'toolsUpgradePolicy'),
               ('syncTime' , 'syncTimeWithHost'), ))

    if verbose:
        pf( 'Flags', '', vm_conf.flags,
            sorted( ( 'disableAcceleration',
                      'enableLogging',
                      'useToe',
                      'runWithDebugInfo',
                      'monitorType',
                      'htSharing',
                      'snapshotDisabled',
                      'snapshotLocked',
                      'diskUuidEnabled',
                      'virtualMmuUsage',
                      'virtualExecUsage',
                      'snapshotPowerOffBehavior',
                      'recordReplayEnabled',
                      'faultToleranceType',
                      'cbrcCacheEnabled', )))

    if verbose:
        pf( 'Power Ops', '', vm_conf.defaultPowerOps,
            sorted( ( 'powerOffType',
                      'suspendType',
                      'resetType',
                      'defaultPowerOffType',
                      'defaultSuspendType',
                      'defaultResetType',
                      'standbyAction', )))

    if True:
        for nic in vsi.vmguest_nic_info( vm ):
            pf( nic[ 'label' ], '{} on "{}"'.format( nic[ 'type' ], nic[ 'netlabel' ] ),
                nic, ( 'macAddress', ) )

            if verbose:
                obj = nic[ 'obj' ]
                pi( farindentL, 'wakeOnLanEnabled',  obj.wakeOnLanEnabled )
                pi( farindentL, 'startConnected',    obj.connectable.startConnected )
                pi( farindentL, 'connected',         obj.connectable.connected )
                pi( farindentL, 'allowGuestControl', obj.connectable.allowGuestControl )

            cidr = nic.get( 'ip' )
            if cidr:
                spc  = " " * (abs( farindentL ) + abs( indentL ) + 2)
                pi( farindentL, 'IP Addresses', cidr[0] )
                for ip in cidr[1:]:
                    print( spc, ip )

    # This is a custom key I insert into my VMs
    if verbose:
        try:    p( 'Guest json', ex_conf.guestinfo.json )
        except: pass

    if verbose:
        try:
            annot = vm.config.annotation
            annot = vsl.fold_text( annot, maxlen=70, indent=abs( indentL ) )
            if annot.find ("\n") >= 0:
                annot = "\n" + indentS + annot
            if annot != "":
                p( 'Annotation', annot )
        except:
            pass

    try:
        p( 'Question', rt_conf.question.text )
    except AttributeError:
        pass

    print( sep )

def init_moId_map( vsi ):
    timer = vsl.Timer('init moId map')
    global moId_map
    moId_map = dict( map( lambda o: ( str( o[ 'obj' ]._moId ), o[ 'name' ] ),
                          vsi.get_obj_props( moId_types, [ 'name' ] )))
    timer.report()

def main():
    args = get_args()
    vsi  = vsl.vmomiConnect( args )

    init_moId_map( vsi )

    if args.verbose:
        proplist.extend( proplist_verbose )

    sep = '-' * 78
    if args.vm:
        # Get matching VMs by name.
        vmlist = vsi.find_vm( args.vm )
        if not vmlist:
            return

        # Get the properties we want from the resulting maetches
        vmlist = vsi.get_obj_props( [vim.VirtualMachine], proplist, vmlist )
        n = len( vmlist )
        for vm in vmlist:
            n -= 1
            if not n:
                sep = ""
            print_vm( vsi, vm, args.verbose, sep=sep )
    else:
        vmlist = vsi.get_obj_props( [vim.VirtualMachine], proplist )

        timer = vsl.Timer('sort')
        vmlist.sort( cmp=lambda a, b: cmp( a[ 'name' ], b[ 'name' ] ))
        timer.report()

        timer = vsl.Timer('print')
        n = len( vmlist )
        for vm in vmlist:
            n -= 1
            if not n:
                sep = ""
            print_vm( vsi, vm, args.verbose, sep=sep )
        timer.report()


##########

if __name__ == '__main__':
    main()

# eof
