#!/usr/bin/env python
# vsphere-vm-modify --- make common modifications to virtual machine configuration

# Author: Noah Friedman <friedman@splode.com>
# Created: 2018-09-05
# Public domain

# $Id: vsphere-vm-modify,v 1.20 2018/10/05 00:18:57 friedman Exp $

# Commentary:

# TODO: customize taskwait success status depending on operation.
# We'll need a custom callback to do this, and suppress the default output.

# Code:

from   __future__ import print_function
from   pyVmomi    import vim, vmodl
import vspherelib     as vsl
import sys

def get_args():
    p = vsl.ArgumentParser( loadrc=True )
    p_sub = p.add_subparsers( dest='cmd' )

    p_com_vm = vsl.ArgumentParser( add_help=False )
    p_com_vm.add( 'vm', nargs='+', help='Virtual machines' )

    ## annotate
    p_annotate = p_sub.add_parser( 'annotate', parents=[p_com_vm], help='Set annotation (notes) for VM' )
    p_anno_g   = p_annotate.add_mutually_exclusive_group( required=True )
    p_anno_g.add_argument('-a', '--annotation', default=None, help='Annotation string' )
    p_anno_g.add_argument('-f', '--file', type=vsl.argparse.FileType('r'), default=None, help='Read annotation from file' )

    ## connect, disconnect
    p_com_conn = vsl.ArgumentParser( add_help=False )
    p_com_conn.add_mxbool( ['-C', '--start-connected'],
                           ['-D', '--start-disconnected'],
                           help_true  = 'Keep device connected at boot',
                           help_false = 'Keep device disconnected at boot' )
    p_com_conn.add( 'vm',      nargs=1, help='Virtual machine' )
    p_com_conn.add( 'label',   nargs=1, help='Device label to modify' )

    p_sub.add_parser( 'connect',     help='Connect virtual device',    parents=[p_com_conn] )
    p_sub.add_parser( 'disconnect',  help='Disconnect virtual device', parents=[p_com_conn] )

    ## mem
    p_mem = p_sub.add_parser( 'mem', help='Configure memory settings' )
    p_mem.add( '-s', '--size',   help='Memory size in MiB; if not specified, do not change' )
    p_mem.add_mxbool( ['-E', '--enable-hot-add'], ['-D', '--disable-hot-add'], dest='enable_hot_add' )
    p_mem.add( 'vm',  nargs='+', help='Virtual machines' )

    ## nested-hv
    p_mem = p_sub.add_parser( 'nested-hv', parents=[p_com_vm], help='Nested virtualization configuration' )
    p_mem.add_mxbool( ['-E', '--enable'], ['-D', '--disable'], dest='nestedHV' )

    ## network
    p_net = p_sub.add_parser( 'network', parents=[p_com_vm], help='Assign ethernet device to another network' )
    p_net.add( '-n', '--nic',   dest='nicnum',   required=True, help='NIC device number or label')
    p_net.add( '-l', '--label', dest='netlabel', required=True, help='Network label')

    ## register
    p_register = p_sub.add_parser( 'register',    help='Add existing VM to inventory' )
    p_register.add( '-n', '--name',    default=None, help='Change name of VM; default uses previously registered name')
    p_register.add( '-f', '--folder',  default=None, help='(sub)Folder to place VM in' )
    p_register.add( '-r', '--pool',    default=None, help='Resource pool' )
    p_register.add( '-c', '--cluster', default=None, help='Compute cluster or Host' )
    p_register.add_bool( '-t', '--as-template',      help='Register VM as template' )
    p_register.add_bool( '-k', '--keep-macs',        help='Do not change existing ethernet MAC addresses' )
    p_register.add( 'vmx', nargs=1,                  help='Path to existing vmx file, in the form "[datastore] vm_directory/vm.vmx"' )

    ## reload
    p_sub.add_parser( 'reload', parents=[p_com_vm], help='Reload VM configuration from .vmx' )

    ## rename
    p_rename = p_sub.add_parser( 'rename', help='Rename virtual machine or template' )
    p_rename.add( 'vm',      nargs=1,      help='VM to modify' )
    p_rename.add( 'newname', nargs=1,      help='New name' )

    ## reset_guest_info
    p_sub.add_parser( 'reset-guest-info', parents=[p_com_vm], help='Flush vsphere guest identity cache' )

    ## resolution
    p_res = p_sub.add_parser( 'resolution', help='Set console resolution' )
    p_res.add( 'WxH', nargs=1,   help='Width x Height in pixels' )
    p_res.add( 'vm',  nargs='+', help='Virtual machines' )

    ## to_template
    p_sub.add_parser( 'to-template', parents=[p_com_vm], help='Convert VM to template' )

    ## to_vm
    p_to_vm = p_sub.add_parser( 'to-vm', parents=[p_com_vm], help='Convert template to virtual machine' )
    p_to_vm.add( '-r', '--pool',    default=None, help='Resource pool' )
    p_to_vm.add( '-c', '--cluster', default=None, help='Compute cluster or Host' )

    ## tools_mount
    p_sub.add_parser( 'tools-mount',   parents=[p_com_vm], help='Mount guest tools installer on virtual cd-rom' )
    ## tools_unmount
    p_sub.add_parser( 'tools-unmount', parents=[p_com_vm], help='Unmount guest tools installer' )
    ## tools_update
    p_sub.add_parser( 'tools-update',  parents=[p_com_vm], help='Update guest tools automatically (when supported)' )

    ## unregister
    p_sub.add_parser( 'unregister',    parents=[p_com_vm], help="Remove VM from inventory but don't delete" )

    ## upgrade
    p_upgrade = p_sub.add_parser( 'upgrade', parents=[p_com_vm], help='Upgrade guest hardware version' )
    p_upgrade.add( '-v', '--version', type=int, default=None, metavar='N',   help='Upgrade to version N' )
    p_upgrade.add( '-a', '--always',
                   dest   = 'upgradePolicy', default = 'onSoftPowerOff',
                   action = 'store_const',   const   = 'always',
                   help = ( '''
             If the machine is currently powered on, virtual hardware
             upgrades will normally be scheduled after the VM guest shuts
             down cleanly.  Using this option means schedule the upgrade no
             matter how the VM might be reset, including host faults. ''' ) )

    ## vcpu
    p_vcpu = p_sub.add_parser( 'vcpu', parents=[p_com_vm], help='Configure number of virtual processors' )
    p_vcpu.add( '-n', '--number', required=True,  help='Total number of vcpus' )
    p_vcpu.add( '-s', '--sockets',                help='Number of cpu sockets' )
    p_vcpu.add_mxbool( ['-A', '--enable-hot-add'],    ['-D', '--disable-hot-add'],    dest='enable_hot_add' )
    p_vcpu.add_mxbool( ['-R', '--enable-hot-remove'], ['-S', '--disable-hot-remove'], dest='enable_hot_remove' )
    #vvtdEnabled vim.vm.FlagInfo()
    #p_vcpu.add_mxbool( ['-V', '--enable-vvtd'], ['-W', '--disable-vvtd'], dest='enable_vvtd' )

    return p.parse()


class mVM():
    def __init__( self, vsi, args ):
        self.vsi    = vsi
        self.args   = args
        self.task   = []
        self.method = getattr( self, args.cmd.replace( '-', '_' ) )

    def doit( self ):
        try:
            targets = self.args.vm
        except AttributeError:
            targets = self.args.vmx

        for arg in targets:
            try:
                task = self.method( arg )
                if task:
                    self.task.append( task )
            except vmodl.MethodFault as e:
                vsl.printerr( rest[0], e.msg )

    def _vm_reconfig_prep( self, vm_name ):
        vm = self.vsi.get_vm( vm_name )
        cfgspec = vim.vm.ConfigSpec()
        cfgspec.changeVersion = vm.config.changeVersion
        return (vm, cfgspec)

    def annotate( self, vm_name ):
        vm, cfgspec = self._vm_reconfig_prep( vm_name )
        if self.args.file:
            cfgspec.annotation = self.args.file.read()
            self.args.file.close()
        else:
            cfgspec.annotation = self.args.annotation
        return vm.ReconfigVM_Task( cfgspec )

    def connect( self, vm_name, connect=True ):
        vm, cfgspec = self._vm_reconfig_prep( vm_name )

        devlabel = self.args.label
        dev = filter( lambda n: n.deviceInfo.label == devlabel,
                      vm.config.hardware.device )
        if not dev:
            raise vsl.NameNotFoundError(
                '{}: "{}" device not found'.format( name, devlabel ))

        devspec           = vim.vm.device.VirtualDeviceSpec()
        devspec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
        devspec.device    = dev[0]

        devspec.device.connectable.connected = connect
        devspec.device.connectable.startConnected = self.args.start_connected

        cfgspec.deviceChange = [ devspec ]
        return vm.ReconfigVM_Task( cfgspec )

    def disconnect( self, vm_name ):
        return self.connect( vm_name, connect=False )

    def mem( self, vm_name ):
        vm, cfgspec = self._vm_reconfig_prep( vm_name )
        cfgspec.memoryMB            = long( self.args.size )
        cfgspec.memoryHotAddEnabled = self.args.enable_hot_add
        return vm.ReconfigVM_Task( cfgspec )

    def nested_hv( self, vm_name ):
        vm, cfgspec = self._vm_reconfig_prep( vm_name )
        cfgspec.nestedHVEnabled = self.args.nestedHV
        return vm.ReconfigVM_Task( cfgspec )

    def network( self, vm_name ):
        vm, cfgspec = self._vm_reconfig_prep( vm_name )

        try:
            nicnum = int( self.args.nicnum )
            niclabel = 'Network adapter {}'.format( nicnum )
        except ValueError:
            niclabel = self.args.nicnum

        netlabel = self.args.netlabel
        net      = self.vsi.get_network( netlabel )

        ethernet = vim.vm.device.VirtualEthernetCard
        nic = filter( lambda n: n.deviceInfo.label == niclabel,
                      vsl.get_seq_type( vm.config.hardware.device, ethernet ))
        if not nic:
            raise vsl.NameNotFoundError(
                '{}: "{}" adapter not found'.format( vm_name, niclabel ))

        devspec           = vim.vm.device.VirtualDeviceSpec()
        devspec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
        devspec.device    = nic[0]

        try:
            dvs_port = vim.dvs.PortConnection()
            dvs_port.portgroupKey = net.key
            dvs_port.switchUuid   = net.config.distributedVirtualSwitch.uuid

            devspec.device.backing = ethernet.DistributedVirtualPortBackingInfo()
            devspec.device.backing.port = dvs_port
        except AttributeError:
            devspec.device.backing = ethernet.NetworkBackingInfo()
            devspec.device.backing.network = net
            devspec.device.backing.deviceName = netlabel

        cfgspec.deviceChange = [ devspec ]
        return vm.ReconfigVM_Task( cfgspec )


    def register( self, vmx ):
        folder_map = self.vsi.path_to_subfolder_map()
        folder     = folder_map[ self.args.folder ]
        cluster    = self.vsi.get_cluster( self.args.cluster )
        if self.args.pool:
            pool = self.vsi.get_pool( self.args.pool, cluster.resourcePool.resourcePool )
        else:
            pool = cluster.resourcePool

        istmpl = self.args.as_template
        if vmx.find(".vmtx", -5) >= 0:
            istmpl=True

        return folder.RegisterVM_Task( name       = self.args.name,
                                       path       = vmx,
                                       pool       = pool,
                                       asTemplate = istmpl )

    def register_mark_moved( self, vm_name ):
        vm, cfgspec = self._vm_reconfig_prep( vm_name )
        kv = vim.option.OptionValue( key='uuid.action', value='keep' )
        cfgspec.extraConfig.append( kv )
        return vm.ReconfigVM_Task( cfgspec )

    def reload( self, vm_name ):
        self.vsi.get_vm( vm_name ).Reload()

    def rename( self, vm_name ):
        vm, cfgspec = self._vm_reconfig_prep( vm_name )
        cfgspec.name = self.args.newname
        return vm.ReconfigVM_Task( cfgspec )

    def reset_guest_info( self, vm_name ):
        self.vsi.get_vm( vm_name ).ResetGuestInformation()

    def resolution( self, vm_name, WxH ):
        vm = self.vsi.get_vm( vm_name )
        width, height = WxH.split( 'x' )
        vm.SetScreenResolution(
            width  = int( width ),
            height = int( height ))

    def to_template( self, vm_name ):
        return self.vsi.get_vm( vm_name ).MarkAsTemplate()

    def to_vm( self, vm_name ):
        cluster = self.vsi.get_cluster( self.args.cluster )
        pool    = self.vsi.get_pool( self.args.pool, root=cluster )
        return self.vsi.get_vm( name ).MarkAsVirtualMachine( pool=pool )

    def tools_mount( self, vm_name ):
        self.vsi.get_vm( vm_name ).MountToolsInstaller()

    def tools_unmount( self, vm_name ):
        self.vsi.get_vm( vm_name ).UnmountToolsInstaller()

    def tools_update( self, vm_name ):
        return self.vsi.get_vm( vm_name ).UpgradeTools_Task()

    def unregister( self, vm_name ):
        return self.vsi.get_vm( vm_name ).UnregisterVM()

    def upgrade( self, vm_name ):
        vm, cfgspec = self._vm_reconfig_prep( vm_name )
        try:
            version = 'vmx-{:02d}'.format( self.args.version )
        except ValueError:
            version = None
        pst = vim.VirtualMachine.PowerState
        if vm.runtime.powerState == pst.poweredOn:
            # Cannot upgrade vm while powered on; schedule upgrade instead.
            hui = vim.vm.ScheduledHardwareUpgradeInfo(
                versionKey    = version,
                upgradePolicy = self.args.upgradePolicy )
            cfgspec.scheduledHardwareUpgradeInfo = hui
            return vm.ReconfigVM_Task( cfgspec )
        else:
            return vm.UpgradeVM_Task( version=version )

    def vcpu( self, vm_name ):
        vm, cfgspec = self._vm_reconfig_prep( vm_name )
        cfgspec.numCPUs = int( self.args.number )
        try:
            nsock = int( self.args[ 'sockets' ] )
            cfgspec.numCoresPerSocket = cfgspec.numCPUs / nsock
        except (TypeError, ZeroDivisionError):
            pass
        cfgspec.cpuHotAddEnabled    = self.args.enable_hot_add
        cfgspec.cpuHotRemoveEnabled = self.args.enable_hot_remove
        return vm.ReconfigVM_Task( cfgspec )


def main():
    args = get_args()
    vsi  = vsl.vmomiConnect( args )
    mi   = mVM( vsi, args )

    mi.doit()
    if mi.task:
        succ1 = vsi.taskwait( mi.task )
        if ( args.cmd == 'register'
             and     args.keep_macs
             and not args.as_template ):
            mtask = []
            for task in mi.task:
                vm = task.info.result
                mtask.append( mi.register_mark_moved ( vm.name ) )
            if mtask:
                succ2 = vsi.taskwait( mtask )
                if not succ2:
                    sys.exit( 1 )
        if not succ1:
            sys.exit( 1 )

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass

# vsphere-vm-modify ends here
