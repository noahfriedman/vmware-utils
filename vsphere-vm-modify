#!/usr/bin/env python
# $Id: vsphere-vm-modify,v 1.7 2018/08/09 21:41:32 friedman Exp $

from   __future__ import print_function
from   pyVmomi    import vim, vmodl
import vspherelib     as vsl

cmds = { 'to-template' : 'to_template',
         'to-vm'       : 'to_vm',
         'register'    : 'register',
         'unregister'  : 'unregister',
         'annotate'    : 'annotate',
         'network'     : 'network',
         'rename'      : 'rename',
}

class mVM():
    def __init__( self, vsi, args ):
        self.vsi    = vsi
        self.args   = args
        self.task   = []
        self.method = getattr( self, cmds[ self.args.cmd ] )

    def doit( self, *rest ):
        try:
            task = self.method( *rest )
            if task:
                self.task.append( task )
        except vmodl.MethodFault as e:
            vsl.printerr( rest[0].name, e.msg )
        except Exception as e:
            vsl.printerr( 'Caught Exception', str( e ))


    def to_template( self, name ):
        return self.vsi.get_vm( name ).MarkAsTemplate()

    def to_vm( self, name ):
        cluster = self.vsi.get_cluster( args.cluster )
        pool    = self.vsi.get_pool( args.pool, root=cluster )
        return self.vsi.get_vm( name ).MarkAsVirtualMachine( pool=pool )


    def register( self, vmx ):
        folder     = self.vsi.path_to_folder( self.args.folder)
        cluster    = self.vsi.get_cluster(    self.args.cluster )
        if self.args.pool:
            pool = self.vsi.get_pool( self.args.pool, cluster.resourcePool.resourcePool )
        else:
            pool = cluster.resourcePool

        istmpl = self.args.as_template
        if vmx.find(".vmtx", -5) >= 0:
            istmpl=True

        return folder.RegisterVM_Task( name=self.args.name,
                                       path=vmx,
                                       pool=pool,
                                       asTemplate=istmpl )

    def register_mark_moved( self, vm ):
        uuid_action = vim.option.OptionValue( key='uuid.action', value='keep' )
        confspec    = vim.vm.ConfigSpec()
        confspec.extraConfig.append( uuid_action )
        return vm.ReconfigVM_Task( confspec )

    def unregister( self, name ):
        return self.vsi.get_vm( name ).UnregisterVM()

    def annotate( self, name ):
        confspec = vim.vm.ConfigSpec()
        confspec.annotation = self.args.annotation
        return self.vsi.get_vm( name ).ReconfigVM_Task( confspec )

    def network( self, vm_name, num, netlabel ):
        net = self.vsi.get_network( netlabel )
        vm  = self.vsi.get_vm( vm_name )

        ethernet = vim.vm.device.VirtualEthernetCard
        niclabel = 'Network adapter {}'.format( num )
        nic = filter( lambda n: n.deviceInfo.label == niclabel,
                      vsl.get_seq_type( vm.config.hardware.device, ethernet ))
        if not nic:
            raise vsl.NameNotFoundError(
                '{}: "{}" adapter not found'.format( name, niclabel ))

        devspec           = vim.vm.device.VirtualDeviceSpec()
        devspec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
        devspec.device    = nic[0]

        try:
            dvs_port = vim.dvs.PortConnection()
            dvs_port.portgroupKey = net.key
            dvs_port.switchUuid   = net.config.distributedVirtualSwitch.uuid

            devspec.device.backing = ethernet.DistributedVirtualPortBackingInfo()
            devspec.device.backing.port = dvs_port
        except AttributeError:
            devspec.device.backing = ethernet.NetworkBackingInfo()
            devspec.device.backing.network = net
            devspec.device.backing.deviceName = label

        confspec = vim.vm.ConfigSpec( deviceChange=[ devspec ] )
        return vm.ReconfigVM_Task( confspec )


    def rename( self, name, newname ):
        confspec      = vim.vm.ConfigSpec()
        confspec.name = newname
        return self.vsi.get_vm( name ).ReconfigVM_Task( confspec )


def get_args():
    p = vsl.ArgumentParser()
    p.add( '--datacenter',  default=None )
    p.add( '-d', '--datastore',   default=None )
    p.add( '-r', '--pool',        default=None )
    p.add( '-c', '--cluster',     default=None )
    p.add( '-f', '--folder',      default=None )
    p.add( '-n', '--name',        default=None )
    p.add( '-t', '--as-template', action='store_true' )
    p.add( '-a', '--annotation',  default=None )
    p.add( 'cmd', choices=cmds,   help='Command to perform on virtual machines' )
    p.add( 'vm',  nargs='+',      help='VM name(s) and/or modification parameters' )
    return p.parse()


def main():
    args = get_args()
    vsi  = vsl.vmomiConnect( args )
    mi   = mVM( vsi, args )

    if args.cmd == 'rename':
        mi.doit( args.vm[0], args.vm[1] )
    elif args.cmd == 'network':
        if len( args.vm ) < 3:
            mi.doit( args.vm[ 0 ], '1', args.vm[ 1 ] )
        else:
            mi.doit( *args.vm[ 0:3 ] )
    else:
        for vm in args.vm:
            mi.doit( vm )
    if mi.task:
        succ = vsi.taskwait( mi.task )
        if not succ:
            sys.exit( 1 )

        if args.cmd == 'register' and not args.as_template:
            mtask = []
            for task in mi.task:
                vm = task.info.result
                mtask.append( mi.register_mark_moved ( vm ) )
            if mtask:
                succ = vsi.taskwait( mtask )
                if not succ:
                    sys.exit( 1 )

if __name__ == '__main__':
    main()

# eof
