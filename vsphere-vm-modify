#!/usr/bin/env python
# $Id: vsphere-vm-modify,v 1.13 2018/09/12 18:28:07 friedman Exp $

from   __future__ import print_function
from   pyVmomi    import vim, vmodl
import vspherelib     as vsl

cmds = { 'to-template'   : 'to_template',
         'to-vm'         : 'to_vm',
         'register'      : 'register',
         'unregister'    : 'unregister',
         'rename'        : 'rename',

         'network'       : 'network',
         'connect'       : 'connect',
         'disconnect'    : 'disconnect',

         'tools-mount'   : 'tools_mount',
         'tools-unmount' : 'tools_unmount',
         'tools-update'  : 'tools_update',

         'upgrade'       : 'upgrade',
         'resolution'    : 'resolution',
         'annotate'      : 'annotate', }

class mVM():
    def __init__( self, vsi, args ):
        self.vsi    = vsi
        self.args   = args
        self.task   = []
        self.method = getattr( self, cmds[ self.args.cmd ] )

    def doit( self, *rest, **kwargs ):
        try:
            task = self.method( *rest, **kwargs )
            if task:
                self.task.append( task )
        except vmodl.MethodFault as e:
            vsl.printerr( rest[0], e.msg )
        except Exception as e:
            vsl.printerr( 'Caught Exception', str( e ))


    def to_template( self, name ):
        return self.vsi.get_vm( name ).MarkAsTemplate()

    def to_vm( self, name ):
        cluster = self.vsi.get_cluster( self.args.cluster )
        pool    = self.vsi.get_pool( self.args.pool, root=cluster )
        return self.vsi.get_vm( name ).MarkAsVirtualMachine( pool=pool )


    def register( self, vmx ):
        folder     = self.vsi.path_to_folder( self.args.folder)
        cluster    = self.vsi.get_cluster(    self.args.cluster )
        if self.args.pool:
            pool = self.vsi.get_pool( self.args.pool, cluster.resourcePool.resourcePool )
        else:
            pool = cluster.resourcePool

        istmpl = self.args.as_template
        if vmx.find(".vmtx", -5) >= 0:
            istmpl=True

        return folder.RegisterVM_Task( name=self.args.name,
                                       path=vmx,
                                       pool=pool,
                                       asTemplate=istmpl )

    def register_mark_moved( self, vm ):
        uuid_action = vim.option.OptionValue( key='uuid.action', value='keep' )
        cfgspec = vim.vm.ConfigSpec( changeVersion = vm.config.changeVersion )
        cfgspec.extraConfig.append( uuid_action )
        return vm.ReconfigVM_Task( cfgspec )

    def unregister( self, name ):
        return self.vsi.get_vm( name ).UnregisterVM()


    def rename( self, name, newname ):
        vm = self.vsi.get_vm( vm_name )
        cfgspec = vim.vm.ConfigSpec( name          = newname,
                                     changeVersion = vm.config.changeVersion )
        return vm.ReconfigVM_Task( cfgspec )


    def tools_mount( self, vm_name ):
        vm = self.vsi.get_vm( vm_name )
        vm.MountToolsInstaller()

    def tools_unmount( self, vm_name ):
        vm = self.vsi.get_vm( vm_name )
        vm.UnmountToolsInstaller()

    def tools_update( self, vm_name ):
        vm = self.vsi.get_vm( vm_name )
        return vm.UpgradeTools_Task()


    def upgrade( self, vm_name, version=None ):
        vm = self.vsi.get_vm( vm_name )
        return vm.UpgradeVM_Task( version=version )

    def resolution( self, vm_name, WxH ):
        vm = self.vsi.get_vm( vm_name )
        width, height = WxH.split( 'x' )
        vm.SetScreenResolution( width=int( width ), height=int( height ))

    def annotate( self, name ):
        vm = self.vsi.get_vm( name )
        cfgspec = vim.vm.ConfigSpec( annotation    = self.args.annotation,
                                     changeVersion = vm.config.changeVersion )
        return vm.ReconfigVM_Task( cfgspec )


    def network( self, vm_name, num, netlabel ):
        net = self.vsi.get_network( netlabel )
        vm  = self.vsi.get_vm( vm_name )

        ethernet = vim.vm.device.VirtualEthernetCard
        niclabel = 'Network adapter {}'.format( num )
        nic = filter( lambda n: n.deviceInfo.label == niclabel,
                      vsl.get_seq_type( vm.config.hardware.device, ethernet ))
        if not nic:
            raise vsl.NameNotFoundError(
                '{}: "{}" adapter not found'.format( name, niclabel ))

        devspec           = vim.vm.device.VirtualDeviceSpec()
        devspec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
        devspec.device    = nic[0]

        try:
            dvs_port = vim.dvs.PortConnection()
            dvs_port.portgroupKey = net.key
            dvs_port.switchUuid   = net.config.distributedVirtualSwitch.uuid

            devspec.device.backing = ethernet.DistributedVirtualPortBackingInfo()
            devspec.device.backing.port = dvs_port
        except AttributeError:
            devspec.device.backing = ethernet.NetworkBackingInfo()
            devspec.device.backing.network = net
            devspec.device.backing.deviceName = netlabel

        cfgspec = vim.vm.ConfigSpec( deviceChange  = [ devspec ],
                                     changeVersion = vm.config.changeVersion )
        return vm.ReconfigVM_Task( cfgspec )

    def connect( self, vm_name, devlabel, startConnected=None, connect=True ):
        vm  = self.vsi.get_vm( vm_name )

        dev = filter( lambda n: n.deviceInfo.label == devlabel,
                      vm.config.hardware.device )
        if not dev:
            raise vsl.NameNotFoundError(
                '{}: "{}" device not found'.format( name, devlabel ))

        devspec           = vim.vm.device.VirtualDeviceSpec()
        devspec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
        devspec.device    = dev[0]

        devspec.device.connectable.connected = connect
        if startConnected is not None:
            devspec.device.connectable.startConnected = startConnected

        cfgspec = vim.vm.ConfigSpec( deviceChange  = [ devspec ],
                                     changeVersion = vm.config.changeVersion )
        return vm.ReconfigVM_Task( cfgspec )

    def disconnect( self, vm_name, devlabel, startConnected=None ):
        return self.connect( vm_name, devlabel, connect=False, startConnected=startConnected )


def get_args():
    p = vsl.ArgumentParser()
    p.add( '--datacenter',         default=None )
    p.add( '-d', '--datastore',    default=None )
    p.add( '-r', '--pool',         default=None )
    p.add( '-c', '--cluster',      default=None )
    p.add( '-f', '--folder',       default=None )
    p.add( '-n', '--name',         default=None )
    p.add( '-t', '--as-template',                                       action='store_true' )
    p.add( '-a', '--annotation',   default=None )
    p.add( '--start-connected',    default=None, dest='startConnected', action='store_true' )
    p.add( '--start-disconnected', default=None, dest='startConnected', action='store_false' )
    p.add( 'cmd', choices=cmds,   help='Command to perform on virtual machines' )
    p.add( 'vm',  nargs='+',      help='VM name(s) and/or modification parameters' )
    return p.parse()

def main():
    args = get_args()
    vsi  = vsl.vmomiConnect( args )
    mi   = mVM( vsi, args )

    if args.cmd in ('rename', 'resolution'):
        mi.doit( args.vm[0], args.vm[1] )
    elif args.cmd == 'network':
        if len( args.vm ) < 3:
            mi.doit( args.vm[ 0 ], '1', args.vm[ 1 ] )
        else:
            mi.doit( *args.vm[ 0:3 ] )
    elif args.cmd in ('connect', 'disconnect'):
        mi.doit( *args.vm[ 0:2 ], startConnected=args.startConnected )
    else:
        for vm in args.vm:
            mi.doit( vm )
    if mi.task:
        succ = vsi.taskwait( mi.task )
        if not succ:
            exit( 1 )

        if args.cmd == 'register' and not args.as_template:
            mtask = []
            for task in mi.task:
                vm = task.info.result
                mtask.append( mi.register_mark_moved ( vm ) )
            if mtask:
                succ = vsi.taskwait( mtask )
                if not succ:
                    exit( 1 )

if __name__ == '__main__':
    main()

# eof
