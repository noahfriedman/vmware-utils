#!/usr/bin/env python
# $Id: vsphere-vm-clone,v 1.6 2018/05/14 22:53:43 friedman Exp $

from   __future__ import print_function
from   pyVmomi    import vim
import vspherelib     as vsl

import sys

##########
class Stuff: pass

##########
def get_args():
    parser = vsl.ArgumentParser()
    parser.add_argument(       '--template',  required=True, help='Name of template or vm to clone from' )
    parser.add_argument( '--vm-name', '-v',   required=True, help='Name for new vm' )
    parser.add_argument( '--folder',          required=True, help='Path of vSphere folder for vm to appear' )
    parser.add_argument( '--pool',                           help='Resource pool for vm' )
    parser.add_argument( '--datacenter',                     help='Name of the datacenter to use' )
    parser.add_argument( '--datastore',                      help='Name of datastore for vm storage' )
    parser.add_argument( '--cluster',                        help='Name of the cluster or hypervisor host for new vm' )
    args = parser.parse_args()
    return args


##########

def vmclone( vsi, template, opt ):
    vm = Stuff()

    datacenter = vsi.get_datacenter( opt.datacenter )
    folder     = vsi.path_to_folder( opt.folder )
    cluster    = vsi.get_cluster(    opt.cluster )
    datastore  = vsi.get_datastore(  opt.datastore, cluster.datastore )

    if opt.pool:
        pool = vsi.get_pool( opt.pool, cluster.resourcePool.resourcePool )
    else:
        pool = cluster.resourcePool

    relospec           = vim.vm.RelocateSpec()
    relospec.datastore = datastore
    relospec.pool      = pool

    clonespec          = vim.vm.CloneSpec()
    clonespec.location = relospec
    clonespec.powerOn  = False

    try:
        task = template.Clone( folder=folder, name=opt.vm_name, spec=clonespec )
    except Exception as details:
        vsl.printerr( 'exception', details )
        return
    return task

##########
class myCallback():
    def __init__( self, target="", msg=None ):
        self.msg    = msg
        self.newmsg = ""
        self.target = target
        self.pct    = 0

    def callback( self, *param ):
        def status( fmt = "\r{0}: {1} ... {2}% " ):
            s = fmt.format( self.target, self.msg, self.pct )
            print( s, end='' )
            sys.stdout.flush()

        change = param[ 0 ]
        key = change.name
        val = change.val
        if key == 'info':
            if val.description:
                self.newmsg = val.description.message
                self.pct    = val.progress
            else:
                return
        elif key == 'info.description':
            if val:
                self.newmsg = val.message
        elif key == 'info.progress':
            self.pct = change.val
        elif key == 'info.error':
            self.succ = 0
            if ( ( sys.stdout.isatty() and sys.stderr.isatty() )
                 or
                 ( sys.stdout.fileno() ==  sys.stderr.fileno() )):
                print()
            printerr( self.target, val.msg )
            return
        elif key == 'info.state':
            if val == 'success':
                self.pct = 100  # doesn't always get this far
                status()
            print( "\n{0}: {1}\n".format( self.target, val ) )
            sys.stdout.flush()
            return

        if self.newmsg != self.msg:
            if self.msg:
                print()
            self.msg = self.newmsg
        status()


##########
def main():
    args = get_args()
    vsi  = vsl.vmomiConnector( args )

    template = vsi.get_obj( [vim.VirtualMachine], { 'name' : args.template } )
    if template:
        task = vmclone( vsi, template[0], args )
        if task:
            vsi.taskwait( task,
                          printsucc=False,
                          callback=myCallback( args.vm_name ).callback )
    else:
        print( 'template not found' )


if __name__ == "__main__":
    main()

# eof
