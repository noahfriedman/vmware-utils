#!/usr/bin/env python
# $Id: vsphere-vm-tags,v 1.8 2018/10/04 15:51:05 friedman Exp $
# This uses the vSphere Automation SDK for Python as well as pyVmomi.

from __future__ import print_function

import requests
import ssl
import simplejson                               as json

import com.vmware.cis_client                    as cis_client
import com.vmware.cis.tagging_client            as tagging_client

import com.vmware.vapi.std.errors_client        as errors_client
import com.vmware.vapi.std_client               as std_client

import com.vmware.vapi.metadata.metamodel.resource_client as resource_client

from   vmware.vapi.lib.connect              import get_requests_connector
from   vmware.vapi.security.session         import create_session_security_context
from   vmware.vapi.security.user_password   import create_user_password_security_context
from   vmware.vapi.stdlib.client.factories  import StubConfigurationFactory

from   requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings( InsecureRequestWarning )

import vspherelib                               as vsl
from   pyVmomi                              import vim

import pprint
_pp_printer = pprint.PrettyPrinter( indent=2, width=40 )
def _print( *args, **kwargs ):
    for arg in args:
        _pp_printer.pprint( arg, **kwargs )

class vapiConnect():
    def __init__( self, host=None, user=None, passwd=None, vmlist=None ):
        self.vmlist = vmlist
        self.host   = host
        self.user   = user
        self.passwd = passwd

        self.connect()

        self.cat_svc   = tagging_client.Category(       self.stub_config )
        self.tag_svc   = tagging_client.Tag(            self.stub_config )
        self.tag_assoc = tagging_client.TagAssociation( self.stub_config )


    def connect( self ):
        host_url = "https://{}/api".format( self.host )
        self.session        = requests.Session()
        self.session.verify = False
        self.connector   = get_requests_connector( session=self.session, url=host_url )
        self.stub_config = StubConfigurationFactory.new_std_configuration( self.connector )
        self.login()

    def login( self ):
        # Pass user credentials (user/password) in the security context to authenticate.
        self.userpass_ctx = create_user_password_security_context( self.user, self.passwd )
        self.stub_config.connector.set_security_context( self.userpass_ctx )
        # Create the stub for the session service and login by creating a session.
        self.session_id = cis_client.Session( self.stub_config ).create()
        # Successful authentication.  Store the session identifier in the security
        # context of the stub and use that for all subsequent remote requests
        self.session_ctx = create_session_security_context( self.session_id )
        self.stub_config.connector.set_security_context( self.session_ctx )

    def logout( self ):
        if self.stub_config:
            session_svc = cis_client.Session( self.stub_config )
            session_svc.delete()
            self.stub_config = None

    def __del__( self ):
        self.logout()

    # This is slow but appears to be all that works with vSphere 6.0
    def vmid_tags( self ):
        result = {}
        for cat_id in self.cat_svc.list():
            cat = self.cat_svc.get( cat_id )
            cat_name = cat.name

            for tag_id in self.tag_svc.list_tags_for_category( cat_id ):
                tag = self.tag_svc.get( tag_id )
                tag_name = tag.name

                vm_ids = [ obj.id for obj in
                           filter( lambda obj: obj.type == 'VirtualMachine',
                                   self.tag_assoc.list_attached_objects( tag_id )) ]
                for vm_id in vm_ids:
                    try:
                        vm_result = result[ vm_id ]
                    except KeyError:
                        vm_result = result[ vm_id ] = {}
                    try:
                        vm_cat = vm_result[ cat.name ]
                    except KeyError:
                        vm_cat = vm_result[ cat.name ] = []
                    vm_cat.append( tag.name )
        return result

    # WIP - Does this method work at all with vSphere 6.0?
    def vmid_tags_by_vm( self ):
        vm_ids = [ std_client.DynamicID( type = 'VirtualMachine',
                                         id   = str( vm['obj'].id ) )
                   for vm in self.vmlist ]
        tags = self.tag_assoc.list_attached_tags_on_objects( vm_ids )
        _print( tags )

    # WIP - # Does this method work at all with vSphere 6.0?
    def vmid_tags_by_tags( self ):
        tag_ids = []
        for cat_id in self.cat_svc.list():
            tag_ids.extend( self.tag_svc.list_tags_for_category( cat_id ))
        vm_ids = self.tag_assoc.list_attached_objects_on_tags( tag_ids )
        _print( vm_ids )

def main():
    args = vsl.ArgumentParser( loadrc=True ).parse_args()
    vsi  = vsl.vmomiConnect( args )

    obj_props = [ 'name',
                  #'config.template',
                  #'runtime.powerState',
                  'guest.guestState',
                  'guest.hostName',
                  'guest.ipAddress', ]

    t = vsl.Timer('get_obj_props')
    vmlist = vsi.get_obj_props( [vim.VirtualMachine], obj_props )
    t.report()

    t = vsl.Timer('vapiConnect')
    vpi  = vapiConnect( vmlist = vmlist,
                        host   = args.host,
                        user   = args.user,
                        passwd = args.password )
    t.report()

    t = vsl.Timer('vmid_tags')
    vm_tags = vpi.vmid_tags()
    t.report()

    # The fact that these raise Unauthenticated rather than Unauthorized
    # against vSphere 6.0 leads me to suspect that these methods just
    # aren't supported there.
    try:
        t = vsl.Timer('vmid_tags_by_tags')
        vpi.vmid_tags_by_tags()
        t.report()

        t = vsl.Timer('vmid_tags_by_vm')
        vpi.vmid_tags_by_vm()
        t.report()
    except errors_client.Unauthenticated:
        pass

    t = vsl.Timer('make vmtbl')
    vmtbl = {}
    for vm in vmlist:
        if vm[ 'guest.guestState' ] != 'running':
            continue
        del vm[ 'guest.guestState' ]

        vmtbl[ vm.pop( 'name' ) ] = vm
        vmid = vm.pop( 'obj' )._moId

        try:
            vm.update( vm_tags[ vmid ] )
        except KeyError:
            pass

        try:
            vm[ 'hostname' ] = vm.pop( 'guest.hostName' )
        except KeyError:
            pass

        try:
            vm[ 'ip' ] = vm.pop( 'guest.ipAddress' )
        except KeyError:
            pass

    t.report()

    t = vsl.Timer("generate json")
    out = json.dumps( vmtbl,
                      sort_keys      = True,
                      #indent        = None,
                      indent         = 4,
                      separators     = (',', ' : '),
                      check_circular = False )
    t.report()

    print( out )

if __name__ == '__main__':
    main()

# eof
