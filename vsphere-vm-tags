#!/usr/bin/env python
# $Id$

# This uses the vSphere Automation SDK for Python as well as pyVmomi.

from __future__ import print_function

import argparse
import atexit
import requests
import ssl

import pyVim.connect

import com.vmware.cis_client                    as cis_client
import com.vmware.cis.tagging_client            as tagging_client

from   vmware.vapi.lib.connect              import get_requests_connector
from   vmware.vapi.security.session         import create_session_security_context
from   vmware.vapi.security.user_password   import create_user_password_security_context
from   vmware.vapi.stdlib.client.factories  import StubConfigurationFactory

from   requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings( InsecureRequestWarning )

class vapiConnect():
    def __init__( self, host=None, user=None, passwd=None ):
        self.host   = host
        self.user   = user
        self.passwd = passwd
        self.connect()

    def connect( self ):
        host_url = "https://{}/api".format( self.host )
        self.session = requests.Session()
        self.session.verify = False
        # Suppress unverified https request warnings
        self.connector = get_requests_connector( session=self.session, url=host_url )
        self.stub_config = StubConfigurationFactory.new_std_configuration( self.connector )
        self.login()

    def login( self ):
        # Pass user credentials (user/password) in the security context to authenticate.
        self.userpass_ctx = create_user_password_security_context(self.user, self.passwd)
        self.stub_config.connector.set_security_context( self.userpass_ctx )
        # Create the stub for the session service and login by creating a session.
        self.session_id = cis_client.Session( self.stub_config ).create()
        # Successful authentication.  Store the session identifier in the security
        # context of the stub and use that for all subsequent remote requests
        self.session_ctx = create_session_security_context( self.session_id )
        self.stub_config.connector.set_security_context( self.session_ctx )

    def logout( self ):
        if self.stub_config:
            session_svc = cis_client.Session( self.stub_config )
            session_svc.delete()


class ServiceManager():
    def __init__( self, host, user, passwd ):
        self.host   = host
        self.user   = user
        self.passwd = passwd
        self.connect()
        atexit.register( self.disconnect )

    def connect( self ):
        # Connect to vAPI Endpoint on vCenter Server system
        self.vapiconn = vapiConnect( host=self.host,
                                     user=self.user,
                                     passwd=self.passwd )
        self.stub_config = self.vapiconn.stub_config

        # Connect to VIM API Endpoint on vCenter Server system
        context = None
        if hasattr( ssl, '_create_unverified_context' ):
            context = ssl._create_unverified_context()
        self.si = pyVim.connect.SmartConnect( host=self.host,
                                              user=self.user,
                                               pwd=self.passwd,
                                        sslContext=context )
        assert self.si is not None

    def disconnect( self ):
        self.vapiconn.logout()
        pyVim.connect.Disconnect( self.si )


class TagFrob():
    def __init__( self, svc_mgr ):
        self.svc_mgr   = svc_mgr
        self.cat_svc   = tagging_client.Category(       self.svc_mgr.stub_config )
        self.tag_svc   = tagging_client.Tag(            self.svc_mgr.stub_config )
        self.tag_assoc = tagging_client.TagAssociation( self.svc_mgr.stub_config )
        self.cat_name_id_map = {}

        print(self.svc_mgr)
        print(self.cat_svc)
        print(self.tag_svc)
        print(self.tag_assoc)


    def run( self ):
        cats = [ self.cat_svc.get( cat ) for cat in self.cat_svc.list() ]
        for cat in cats:
            self.cat_name_id_map[cat.name] = cat.id
            self.cat_name_id_map[cat.id]   = cat.name

        Owners_id = self.cat_name_id_map['Owners']
        tags = [ self.tag_svc.get( tag ) for tag in self.tag_svc.list() ]
        for tag in tags:
            if tag.category_id != Owners_id:
                continue

            objs = filter( lambda obj: obj.type == 'VirtualMachine',
                           self.tag_assoc.list_attached_objects( tag.id ) )
            if len( objs ) < 1:
                continue

            print( 'VMs owned by {0} ({1}): {2}'.format( tag.name, tag.description, len( objs )))
            objs.sort( lambda a, b: cmp( a.id, b.id ))
            for obj in objs:
                print( '\t{0}'.format( obj.id ))


def main():
    argparser = argparse.ArgumentParser()
    argparser.add_argument('-s', '--server',   help='Hostname of vCenter Server')
    argparser.add_argument('-u', '--username', help='Username to login to the vCenter Server')
    argparser.add_argument('-p', '--password', help='Password to login to the vCenter Server')
    args = argparser.parse_args()

    svc_mgr = ServiceManager( args.server, args.username, args.password )
    tagfrob = TagFrob( svc_mgr )

    tagfrob.run()


if __name__ == '__main__':
    main()

# eof
