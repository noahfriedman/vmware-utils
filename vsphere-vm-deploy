#!/usr/bin/env python
# vsphere-vm-deploy --- upload new vm from ova or ovf spec

# Author: Noah Friedman <friedman@splode.com>
# Created: 2019-10-10
# Public domain

# Commentary:

# This is simiilar in purpose to ovftool when used to deploy new virtual
# machines from local ovf/ova disk files.
#
# Currently it does not:
#	* create ova or ovf files
#       * deploy any other format besides ova or ovf (e.g. not vmx)
# 	* convert between any formats
#	* support vi:// URIs or other network methods for either
#	  source or destination
#	* validate checksums in .mf file
#       * export (download) virtual machines
#
# What it does do:
#       * provide more readable status of upload progress and more
#         informative diagnostics when something goes wrong.
#       * support loading of deployment defaults from $VSPHERELIBRC

# Code:

from   __future__ import print_function


import os
import re
import sys
import ssl
import tarfile
import threading
import time
import six.moves.urllib.request as request

from   pyVmomi    import vim, vmodl
import vspherelib     as vsl


class OvfHandlerBase( vsl._super, vsl._with ):
    required_kwargs = [ 'vm_name', 'host', 'vsi', 'pool', 'ds', 'disk_format', 'network', 'folder' ]
    default_disk_format = 'thin'

    def __init__( self, **kwargs ):
        missing = { name : None for name in self.required_kwargs }
        for arg in kwargs:
            setattr( self, arg, kwargs[ arg ] )
            if arg in missing:
                del missing[ arg ]
        if missing:
            fmt = 'Missing class keyword parameters: {}'
            msg = fmt.format( ', '.join( missing.keys() ))
            raise vsl.ApiError( msg )

    def _ovfd_readin( self, fh ):
        # Change the name of the vm in the ovf descriptor from whatever
        # it has currently to that of the one named on the command line.
        #
        # This is absolutely not the right way to (not) traverse xml
        # paths and modify them.  But do YOU want to pull in a full
        # parser for this one trivial change?
        self.ovfd = re.sub(
            '<(Name|vssd:VirtualSystemIdentifier)>.*?</\\1>',
            str.format( '<\\1>{}</\\1>', self.vm_name ),
            fh.read() )

    @vsl.tidy_vimfaults
    def _init_spec( self ):
        vimOvfM = vim.OvfManager
        natmap  = vimOvfM.NetworkMapping( name='nat', network=self.network )
        param   = vimOvfM.CreateImportSpecParams()
        param.networkMapping.append( natmap )

        OvfMgr = self.vsi.si.content.ovfManager
        # If anything is wrong this will raise an exception in some
        # circumstances (e.g. permission error), or just return error
        # messages in others (missing or incomplete items, etc)
        self.spec = OvfMgr.CreateImportSpec( self.ovfd, self.pool, self.ds, param )
        if not self.spec.importSpec:
            summary = "Could not create import spec:"
            if len( self.spec.error ) == 1:
                diag = vsl.Diag ( summary, self.spec.error[0].msg, sep=' ' )
            else:
                diag = vsl.Diag ( summary )
                for error in self.spec.error:
                    diag.append( '\t' + error.msg )
            raise vsl.cliGeneralError( diag )

        vd = vim.vm.device.VirtualDisk
        for disk in filter( lambda elt: isinstance( elt.device, vd ),
                            self.spec.importSpec.configSpec.deviceChange ):
            disk.device.backing = self._disk_backing_spec()

    def _disk_backing_spec( self ):
        vd = vim.vm.device.VirtualDisk
        fmt = self.disk_format or self.default_disk_format
        if fmt in ['sesparse']:
            backing = vd.SeSparseBackingInfo()
        else:
            backing = vd.FlatVer2BackingInfo()
            backing.split = False
            if fmt in ['thin']:
                backing.thinProvisioned = True
            elif fmt in ['thick', 'zeroedthick']:
                pass
            elif fmt in ['eagerzeroedthick']:
                backing.eagerlyScrub = True
        backing.diskMode = 'persistent'
        return backing

    def _init_lease( self ):
        lease = self.pool.ImportVApp( self.spec.importSpec, self.folder )
        self.lease = lease

        msg   = "Initializing... {:d}%"
        while lease.state == vim.HttpNfcLease.State.initializing:
            self.print_status( msg.format( lease.initializeProgress ))
            time.sleep( 1 )
        self.print_status( msg.format( 100 ), end='\n' )

        if lease.state == vim.HttpNfcLease.State.error:
            diag = vsl.Diag( "Error: %s\n" % lease.error.msg )
            raise vsl.cliGeneralError( diag )

        return lease

    def _device_url( self, entry ):
        for url in self.lease.info.deviceUrl:
            if url.importKey == entry.deviceId:
                return url

    def upload( self ):
        lease = self._init_lease()
        try:
            self.start_timer()
            for elt in self.spec.fileItem:
                self._upload_entry( elt )
            lease.Complete()

            self.print_status( "Finished.\n" )
            return 0
        except vmodl.MethodFault as e:
            lease.Abort( e )
            raise vsl.cliGeneralError( str( e ) )
        except Exception as e:
            reason = vmodl.fault.SystemError( reason=str( e ) )
            lease.Abort( reason )
            raise

    def _upload_entry( self, name ):
        self.current_entry = self.get_entry( name )
        url = self._device_url( name ).url.replace( '*', self.host )
        headers = { 'Content-length': self.current_entry.size }
        try:
            sslContext = ssl._create_unverified_context()
        except AttributeError:
            sslContext = None
        req = request.Request( url, self.current_entry, headers )
        request.urlopen( req, context=sslContext )
        time.sleep( 1 )
        self.print_upload_status( end='\n' )

    def print_upload_status( self, end='' ):
        entry = self.current_entry
        size  = entry.size
        pos = '{0:>{1},d} / {2:<,d}'.format( entry.tell(), len( str( size )), size )
        pcts = '... {:.2f}%'.format( self.progress() )
        self.print_status( 'Uploading', self.current_entry.name, pos, pcts, end=end )

    def print_status( self, *args, **kwargs ):
        file = kwargs.get( 'file', sys.stderr )
        sep  = kwargs.get( 'sep',  ' ' )
        end  = kwargs.get( 'end',  '' if file.isatty() else '\n' )
        if args[0][0] in ['\r', '\n']:
            args = list( args )  # need to modify
            prefix = args[0][0]
            args[0] = args[0][ 1: ]
        else:
            prefix = '\r'
        arg0 = '{}{}: {}'.format( prefix, self.vm_name, args[0] )
        print( arg0, *args[ 1: ], sep=sep, end=end, file=file )
        if kwargs.get( 'flush', True ):
            file.flush()

    def start_timer(self):
        threading.Timer( 1, lambda: self.timer() ).start()

    def timer( self ):
        try:
            if self.lease.state not in [ vim.HttpNfcLease.State.done,
                                         vim.HttpNfcLease.State.error ]:
                self.lease.Progress( int( self.progress() ))
                self.print_upload_status()
                self.start_timer()
        except (AttributeError, vmodl.fault.ManagedObjectNotFound) as e:
            print(e)
            pass


class OvaHandler( OvfHandlerBase ):
    def __init__( self, filename, **kwargs ):
        self.super.__init__( **kwargs )

        self.fh      = open( filename, 'rb' )
        self.fh_size = os.fstat( self.fh.fileno() ).st_size
        self.tar     = tarfile.open( fileobj=self.fh )

        self._ovfd_readin( self.get_entry( lambda x: x.endswith( ".ovf" ) ))
        self._init_spec()

    def get_entry( self, entry ):
        members = self.tar.getnames()
        if callable( entry ):
            res = filter( entry, members )
        else:
            try:
                res = filter( lambda p: p == entry.path, members )
            except AttributeError:
                res = filter( lambda p: p == entry, members )
        if res:
            return self.tar.extractfile( res[0] )

    def progress( self ):
        return round( 100.0 * self.fh.tell() / self.fh_size, 2 )


class OvfHandler( OvfHandlerBase ):
    class DiskFile( file ):
        # Provides one additional property over base file class, which
        # cannot itself be modified with arbitrary instance attributes.
        size = property( lambda self: self._size() )
        def _size( self ):
            try:
                return self.st_size
            except AttributeError:
                self.st_size = os.fstat( self.fileno() ).st_size
                return self.st_size

    def __init__( self, ovf, **kwargs ):
        self.super.__init__( **kwargs )

        with open( ovf, 'r' ) as f:
            self._ovfd_readin ( f )

        self.dirname = re.sub( '/[^/]+$', '/', ovf )
        if self.dirname == ovf:
            self.dirname = ''

        self._init_spec()
        self.entry_total_size = 0
        self.entry_uploaded_offset = 0
        self.entry_sizes = []
        self.entry_curno = -1
        for elt in self.spec.fileItem:
            self.entry_total_size += elt.size
            self.entry_sizes.append( elt.size )

    def get_entry( self, entry ):
        if self.entry_curno >= 0:
            self.entry_uploaded_offset += self.entry_sizes.pop( 0 )
        self.entry_curno += 1
        return self.DiskFile( self.dirname + entry.path )

    def progress( self ):
        pos = self.entry_uploaded_offset + self.current_entry.tell()
        return round( 100.0 * pos / self.entry_total_size, 2 )



formats = [ 'sesparse', 'thin', 'zeroedthick', 'eagerzeroedthick' ]

def get_args():
    p = vsl.ArgumentParser( loadrc=True )
    p.add( '-n', '--name',        required=1,      help='VM name' )
    p.add( '-a', '--annotation',                   help='Annotation for new VM' )
    p.add( '-F', '--disk-format', choices=formats, help='Format for VM disks' )
    p.add( 'ova',  nargs=1,                        help='ova or ovf file' )
    return p.parse()

def main():
    args    = get_args()
    vsi     = vsl.vmomiConnect( args )

    dc      = vsi.get_datacenter(       args.datacenter )
    cl      = vsi.get_compute_resource( args.cluster,   root=dc.hostFolder.childEntity )
    ds      = vsi.get_datastore(        args.datastore, root=cl.datastore )
    pool    = vsi.get_resource_pool(    args.pool,      root=cl.resourcePool )
    network = vsi.get_network(          args.network,   root=cl.network )
    folder  = vsi.path_to_subfolder_map( 'vm' )[ args.folder ]

    with open( args.ova[ 0 ] ) as f:
        beg = f.read( 16 )
    if beg.startswith( '<?xml version=' ):
        OVATYPE = OvfHandler
    else:
        OVATYPE = OvaHandler
    ova = OVATYPE(     args.ova[ 0 ],
                       vm_name = args.name,
                          host = args.host,
                           vsi = vsi,
                          pool = pool,
                            ds = ds,
                   disk_format = args.disk_format,
                       network = network,
                        folder = folder )
    return ova.upload()

if __name__ == '__main__':
    sys.exit( main() )
